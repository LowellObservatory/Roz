# -*- coding: utf-8 -*-
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
#  Created on 05-Oct-2022
#
#  @author: tbowers

"""Module containing toolbox utilities for processing All-Sky Images

This module is part of the Roz package, written at Lowell Observatory.

Images from the All-Sky Cameras require aditional specialized processing in
order to make use of the data for sky quality monitoring purposes.  The
routines here are based on algorithms from the `kpno-allsky package
<https://github.com/dylanagreen/kpno-allsky>`_.

This module primarily trades in, um, stuff?

.. include common links, assuming primary doc root is up one directory
.. include:: ../include/links.rst
"""

# Built-In Libraries
import bz2
import gzip
import os
import pathlib
import re
import shutil
import tarfile
import warnings

# 3rd Party Libraries
import astropy.convolution
import astropy.io.fits
import astropy.nddata
import astropy.units as u
from astropy.utils.exceptions import AstropyUserWarning
import astropy.visualization
import astropy.wcs
import ccdproc
import matplotlib.pyplot as plt
import numpy as np
import PIL.Image
import scipy.ndimage
from tqdm import tqdm
import ffmpeg

# Internal Imports
from roz import graphics_maker
from roz import msgs
from roz import utils

# Set API Components
# __all__ = ['generate_mask','gener']

LDT_ASC = {"xcen": (683), "ycen": 489, "mrad": 518}
SIXTEEN_BIT = 2**16 - 1

# Silence Superflous AstroPy FITS Header Warnings
warnings.simplefilter("ignore", astropy.wcs.FITSFixedWarning)


def generate_mask(icl: ccdproc.ImageFileCollection, forcenew=False):
    """Generate a complete mask for Lowell All-Sky Images

    The mask generated by this function is a BAD PIXEL MASK, in that a value
    of 0 indicates the pixel should remain visible, and masked pixels are
    marked by bitwise value:

    1. Hot pixels
    2. Horizon objects
    3. Pixels outside the circular All-Sky Image.

    Parameters
    ----------
    icl : `ccdproc.ImageFileCollection`_
        The Image File Collection for this night, used to generate masks
    forcenew : bool, optional
        Force the generation of a mask completely from scratch rather than use
        a saved mask?  (Default: False)

    Returns
    -------
    `numpy.ndarray`_
        The mask array where 0 represents pixels that are to be masked and 1
        represents pixels that should remain visible.

    See Also
    --------
    generate_object_mask : Used by generate_mask to generate the hot pixel
                    and horizon masks.

    Notes
    -----
    generate_mask calls generate_object_mask, which requires there to be
    median images in Images/mask/ but also additionally requires an image
    named Ignore.png in Images/ that deliniates the horizon objects to be
    ignored. These images can be downloaded from the kpno-allsky github.
    """

    msgs.info("Generating masks...")

    # The other two masks
    mask1 = generate_hotpixel_mask(icl)
    # mask2 = generate_object_mask(forcenew)
    mask3 = generate_radius_mask(next(icl.ccds(ccd_kwargs={"unit": u.adu})).data)

    return mask1 | mask3


def generate_radius_mask(input_image: np.ndarray):
    """generate_radius_mask _summary_

    _extended_summary_

    Parameters
    ----------
    input_image : `numpy.ndarray`_
        The input image for which the mask will be generated.

    Returns
    -------
    `numpy.ndarray`_
        The BAD PIXEL MASK for radius from the center of the all-sky image,
        of the same shape as ``input_image``.  Good pixels have a value of
        0, and bad pixels have a value of 1.
    """
    # Construct the arrays for doing the matrix magic -- origin in center
    n_y, n_x = input_image.shape
    x_arr = np.tile(np.arange(n_x), (n_y, 1)) - LDT_ASC["xcen"]
    y_arr = np.transpose(np.tile(np.arange(n_y), (n_x, 1))) - LDT_ASC["ycen"]

    # Return the mask identifying pixels outside the specified radius
    return (np.hypot(x_arr, y_arr) > LDT_ASC["mrad"]).astype(int)


def generate_hotpixel_mask(icl: ccdproc.ImageFileCollection, hot_lim=0.25, f_dark=0.75):
    """Generate a hot pixel mask for a night's worth of AllSky Data

    After playing around with this, it seems the best criteria for identifying
    hot pixels in a night's ASC data is to find all pixels whose value >= 25%
    of saturation in 3/4 of the 60-second (i.e., DARK) frames.

    For the LDT all-sky camera, this should identify something in the range of
    50 hot pixels.

    Returns
    -------
    `numpy.ndarray`_
        The BAD PIXEL MASK of identified hot pixels, of the same shape as the
        images in ``icl``.  Good pixels have a value of 0, and bad pixels
        have a value of 1.
    """

    # Show progress bar for processing ASC frames
    msgs.info("Processing frames to generate a hot pixel mask...")
    progress_bar = tqdm(
        total=len(icl.files), unit="frame", unit_scale=False, colour="#eab676"
    )

    # Set empty return item and DARK counter
    hotpix, n_dark = None, 0

    for ccd in icl.ccds(ccd_kwargs={"unit": u.adu}):

        if float(ccd.header["exptime"]) < 60:
            continue

        # LR flip the image and convert to float
        ccd.data = np.fliplr(ccd.data.astype(float))

        # Find the "HOT PIXELS" in this image, and add them to the mask
        hpm = (ccd.data > hot_lim * SIXTEEN_BIT).astype(int)
        hotpix = hpm if hotpix is None else hotpix + hpm

        n_dark += 1
        progress_bar.update(1)

    progress_bar.close()

    # Identify pixels marked as HOT in `f_dark` of the DARK frames
    return (hotpix >= f_dark * n_dark).astype(int)


def generate_object_mask(forcenew=False):
    """Generate a mask for KPNO images.

    Generates a masking array for KPNO images that masks out not only hot
    pixels, but also the horizon objects.

    Parameters
    ----------
    forcenew : bool, optional
        Whether or not this method should load a previously saved mask or if it
        should generate it completely from scratch.

    Returns
    -------
    `numpy.ndarray`_
        The mask array where 1 represents pixels that are to be masked and 0
        represents pixels that should remain visible.

    See Also
    --------
    generate_clean_mask : Used by generate_mask to generate the hot pixel
                          mask.

    Notes
    -----
    generate_mask requires there to be median images in Images/mask/ but also
    additionally requires an image named Ignore.png in Images/ that
    deliniates the horizon objects to be ignored.
    These images can be downloaded from the kpno-allsky github or may be
    generated by median.median_all_date and moved.

    """
    center = (256, 252)

    # Read in the ignore image.
    # I read this in first to make sure the Mask.png is the correct dimensions.
    ignore_loc = os.path.join(os.path.dirname(__file__), *["Images", "Ignore.png"])
    ignore = np.asarray(PIL.Image.open(ignore_loc).convert("RGB"))

    # If we"ve already generated and saved a mask, load that one.
    # This speeds up code execution by a lot, otherwise we loop through 512x512
    # pixels 6 times! With this we don"t have to even do it once, we just load
    # and go.
    maskloc = os.path.join(os.path.dirname(__file__), *["Images", "Mask.png"])
    if os.path.isfile(maskloc) and not forcenew:
        mask = np.asarray(PIL.Image.open(maskloc).convert("L"))
        # Converts the 255 bit loaded image to binary 1-0 image.
        mask = np.where(mask == 255, 1, 0)

        # Have to compare these two separately, since ignore has a third color
        # dimensions and mask.shape == ignore.shape would therefore always be
        # False.
        if mask.shape[0] == ignore.shape[0] and mask.shape[1] == ignore.shape[1]:
            return mask

    # Get the "clean" mask, i.e. the pixels only ignore mask.
    mask = generate_hotpixel_mask()

    hyp = np.hypot
    for y in range(0, ignore.shape[1]):
        for x in range(0, ignore.shape[0]):
            x1 = x - center[0]
            y1 = center[1] - y
            r = hyp(x1, y1)

            # Ignore horizon objects (which have been painted pink)
            # Only want the horizon objects actually in the circle.
            # Avoids unnecessary pixels.
            if r < 242 and np.array_equal(ignore[y, x], [244, 66, 235]):
                mask[y, x] = 1

    # If we've made a new mask, save it so we can skip the above steps later.
    save_mask(mask)

    return mask


def save_mask(mask):
    """Save a masking image.

    Parameters
    ----------
    mask : `numpy.ndarray`_
        The mask to save.

    See Also
    --------
    image.save_image : Save an image.

    """


def test_animations():
    """Test creating animations

    _extended_summary_
    """
    msgs.info("Reading in the ImageFileCollection...")
    icl = ccdproc.ImageFileCollection(
        "/Users/tbowers/sandbox/", glob_include="TARGET*.fit"
    )

    # Show progress bar for processing ASC frames
    msgs.info("Processing frames...")
    progress_bar = tqdm(
        total=len(icl.files), unit="frame", unit_scale=False, colour="#eab676"
    )

    sobel_mask = None

    for i, ccd in enumerate(icl.ccds(ccd_kwargs={"unit": u.adu})):

        # Set FITS keyword for image scaling
        ccd.header["OBSTYPE"] = "DOME FLAT"  # "OBJECT"

        # LR flip the image and convert to float
        ccd.data = np.fliplr(ccd.data.astype(float))

        # Generate the mask(s)

        # Convert the image into a masked array
        m_idx = generate_radius_mask(ccd.data) != 0
        # ccd.data = np.ma.array(ccd.data, mask=m_idx)
        ccd.data = scipy.ndimage.sobel(ccd.data)

        # Add to the Sobel Mask
        sobel_mask = ccd.data if sobel_mask is None else sobel_mask + ccd.data

        # Set up the plotting environment
        _, axis = plt.subplots()

        # Get image limits
        vmin, vmax = graphics_maker.get_image_intensity_limits(ccd)

        # Show the data on the plot, using the limits computed above
        axis.imshow(ccd.data, vmin=vmin, vmax=vmax, origin="lower")
        axis.axis("off")

        # # Show the pixel histogram on the plot, marking the limits from above
        # axis.hist(ccd.data.flatten(), bins=100, range=(0,65535), histtype='step')
        # axis.vlines([vmin, vmax], 0, 1, transform=axis.get_xaxis_transform())
        # axis.set_yscale('log')
        # axis.set_ylim(0.6, 1e6)

        # Finish up
        plt.tight_layout()
        plt.savefig(f"/Users/tbowers/sandbox/asc_{ccd.header['seqnum']:05d}.png")
        plt.close()
        progress_bar.update(1)

        # if (i+1) % 20 == 0:
        #     break

    progress_bar.close()

    # Create the MP4 animation; the operable command should be like:
    # ffmpeg -framerate 30 -pattern_type glob -i '*.png' \
    #   -c:v libx264 -pix_fmt yuv420p out.mp4
    stream = ffmpeg.input(
        "/Users/tbowers/sandbox/asc_*.png", framerate=30, pattern_type="glob"
    )
    stream = ffmpeg.output(
        stream,
        "/Users/tbowers/sandbox/asc_night.mp4",
        pix_fmt="yuv420p",
        vcodec="libx264",
    )
    msgs.info(f"{ffmpeg.compile(stream)}")
    ffmpeg.run(stream, overwrite_output=True)

    # Open the animation
    os.system(f"/usr/bin/open /Users/tbowers/sandbox/asc_night.mp4")

    # Set up the plotting environment for the final SOBEL mask
    sccd = astropy.nddata.CCDData(sobel_mask, unit=u.adu)
    sccd.write("/Users/tbowers/sandbox/sobel_sum.fits", overwrite=True)

    _, axis = plt.subplots()

    # Compute the iterval
    pmin, pmax = 0, 100
    interval = astropy.visualization.AsymmetricPercentileInterval(
        pmin, pmax, n_samples=10000
    )
    vmin, vmax = interval.get_limits(sobel_mask)
    # Show the data on the plot, using the limits computed above
    axis.imshow(sobel_mask, vmin=vmin, vmax=vmax, origin="lower")
    axis.axis("off")
    # Finish up
    plt.tight_layout()
    plt.show()
    plt.close()


def test_hotpix(hot_lim):
    """Test finding hot pixels

    _extended_summary_
    """
    msgs.info("Reading in the ImageFileCollection...")
    icl = ccdproc.ImageFileCollection(
        "/Users/tbowers/sandbox/", glob_include="TARGET*.fit"
    )

    # Show progress bar for processing ASC frames
    msgs.info("Processing frames...")
    progress_bar = tqdm(
        total=len(icl.files), unit="frame", unit_scale=False, colour="#eab676"
    )

    hotpix = None
    i = 0
    for ccd in icl.ccds(ccd_kwargs={"unit": u.adu}):

        # Set FITS keyword for image scaling
        ccd.header["OBSTYPE"] = "DOME FLAT"  # "OBJECT"

        if float(ccd.header["exptime"]) < 60:
            continue

        # LR flip the image and convert to float
        ccd.data = np.fliplr(ccd.data.astype(float))
        hpm = (ccd.data > hot_lim * 65535).astype(int)

        hotpix = hpm if hotpix is None else hotpix + hpm

        i += 1
        progress_bar.update(1)

    progress_bar.close()
    msgs.info(f"Total Number of frames: {len(icl.files)}")
    msgs.info(f"Maximum value in hotpix: {hotpix.max()}")
    msgs.info(
        f"Number of pixels at the max value: {np.count_nonzero(hotpix[hotpix == hotpix.max()])}"
    )
    n_hot = []
    for maxval in (maxvals := np.arange(200, len(icl.files), 10)):
        msgs.info(
            f"Number of pixels exceeding {maxval} frames: {np.count_nonzero(hotpix[hotpix > maxval])}"
        )
        n_hot.append(np.count_nonzero(hotpix[hotpix > maxval]))

    # Set up the plotting environment for the final SOBEL mask
    sccd = astropy.nddata.CCDData(hotpix, unit=u.adu)
    sccd.write("/Users/tbowers/sandbox/hotpix_sum.fits", overwrite=True)

    # _, axis = plt.subplots()
    # # axis.hist(hotpix.flatten(), bins=np.arange(len(icl.files)) + 1, histtype="step")
    # # axis.set_yscale("log")
    # axis.imshow(hotpix, origin="lower", vmin=400, vmax=len(icl.files))
    # plt.tight_layout()
    # plt.show()
    # plt.close()

    return maxvals, np.array(n_hot)


def run_test_hotpix():
    """run_test_hotpix _summary_

    _extended_summary_
    """
    res = {}

    for hot_lim in np.arange(0.2, 0.601, 0.05):
        msgs.info(f"\n  Testing HOT LIMIT ({hot_lim:.2f}) {hot_lim * 65535:.0f}...")
        res[f"{hot_lim:.2f}"] = test_hotpix(hot_lim)

    _, axis = plt.subplots()

    for k, v in res.items():
        axis.plot(v[0], v[1], "o-", label=k)

    axis.legend(loc="upper right")
    axis.set_xlabel("N (60s) Frames this pixel identified in")
    axis.set_ylabel("N pixles identified")
    axis.set_title("Hot Pixel Identification Criteria")
    plt.tight_layout()
    plt.savefig("/Users/tbowers/sandbox/hotpix_identification_criteria.png")
    plt.savefig("/Users/tbowers/sandbox/hotpix_identification_criteria.pdf")
    plt.close()


def test_masking():
    """test_masking _summary_

    _extended_summary_
    """
    msgs.info("Reading in the ImageFileCollection...")
    icl = ccdproc.ImageFileCollection(
        "/Users/tbowers/sandbox/", glob_include="TARGET*.fit"
    )

    hotpix = generate_hotpixel_mask(icl)
    radius = generate_radius_mask(next(icl.ccds(ccd_kwargs={"unit": u.adu})).data)

    # Show progress bar for processing ASC frames
    msgs.info("Processing frames...")
    progress_bar = tqdm(
        total=len(icl.files), unit="frame", unit_scale=False, colour="#eab676"
    )

    for ccd in icl.ccds(ccd_kwargs={"unit": u.adu}):

        # Set FITS keyword for image scaling
        ccd.header["OBSTYPE"] = "DOME FLAT"  # "OBJECT"

        # LR flip the image and convert to float
        ccd.data = np.fliplr(ccd.data.astype(float))

        # Mask hot pixels, then interpolate
        ccd.data[hotpix.astype(bool)] = np.nan
        ccd.data = astropy.convolution.interpolate_replace_nans(
            ccd.data, astropy.convolution.Gaussian2DKernel(x_stddev=1)
        )
        # Mask by radius
        ccd.data[radius.astype(bool)] = np.nan

        # Set up the plotting environment
        _, axis = plt.subplots(figsize=(16, 12))

        # Get image limits
        vmin, vmax = graphics_maker.get_image_intensity_limits(ccd)

        # Show the data on the plot, using the limits computed above
        axis.imshow(
            ccd.data, vmin=vmin, vmax=vmax, origin="lower", interpolation="nearest"
        )
        axis.axis("off")

        # # Show the pixel histogram on the plot, marking the limits from above
        # axis.hist(ccd.data.flatten(), bins=100, range=(0,65535), histtype='step')
        # axis.vlines([vmin, vmax], 0, 1, transform=axis.get_xaxis_transform())
        # axis.set_yscale('log')
        # axis.set_ylim(0.6, 1e6)

        # Finish up
        plt.tight_layout()
        plt.savefig(f"/Users/tbowers/sandbox/asc_{ccd.header['seqnum']:05d}.png")
        plt.close()
        progress_bar.update(1)

        # if (i+1) % 20 == 0:
        #     break

    progress_bar.close()

    # Create the MP4 animation; the operable command should be like:
    # ffmpeg -framerate 30 -pattern_type glob -i '*.png' \
    #   -c:v libx264 -pix_fmt yuv420p out.mp4
    stream = ffmpeg.input(
        "/Users/tbowers/sandbox/asc_*.png", framerate=30, pattern_type="glob"
    )
    stream = ffmpeg.output(
        stream,
        "/Users/tbowers/sandbox/asc_night.mp4",
        pix_fmt="yuv420p",
        vcodec="libx264",
    )
    msgs.info(f"{ffmpeg.compile(stream)}")
    ffmpeg.run(stream, overwrite_output=True)

    # Open the animation
    os.system(f"/usr/bin/open /Users/tbowers/sandbox/asc_night.mp4")


def make_clean_sobel_map():
    """Make a clean Sobel map

    First mask and interpolate over hotpixels, then Sobel filter and build up
    a sum sobel map.
    """
    msgs.info("Reading in the ImageFileCollection...")
    icl = ccdproc.ImageFileCollection(
        "/Users/tbowers/sandbox/", glob_include="TARGET*.fit"
    )

    hp_mask = generate_hotpixel_mask(icl)
    msgs.bug(f"Number of marked HOT PIXELS: {np.sum(hp_mask)}")

    # Show progress bar for processing ASC frames
    msgs.info("Processing frames...")
    progress_bar = tqdm(
        total=len(icl.files), unit="frame", unit_scale=False, colour="#eab676"
    )

    sobel_mask = None

    for i, ccd in enumerate(icl.ccds(ccd_kwargs={"unit": u.adu})):

        # Set FITS keyword for image scaling
        ccd.header["OBSTYPE"] = "DOME FLAT"  # "OBJECT"

        # LR flip the image and convert to float
        ccd.data = np.fliplr(ccd.data.astype(float))

        # Apply the hot pixel mask, and interpolate
        msgs.bug(
            f"Number of NaN pixels in unmasked image: {np.sum(np.isnan(ccd.data))}"
        )
        ccd.data[hp_mask.astype(bool)] = np.nan
        msgs.bug(f"Number of NaN pixels in masked image: {np.sum(np.isnan(ccd.data))}")

        ccd.data = astropy.convolution.interpolate_replace_nans(
            ccd.data, astropy.convolution.Gaussian2DKernel(x_stddev=1)
        )
        msgs.bug(
            f"Number of NaN pixels in interpolated image: {np.sum(np.isnan(ccd.data))}"
        )

        # Sobel filter the data
        ccd.data = scipy.ndimage.sobel(ccd.data)

        # Add to the Sobel Mask
        sobel_mask = ccd.data if sobel_mask is None else sobel_mask + ccd.data

        progress_bar.update(1)
    progress_bar.close()

    # Set up the plotting environment for the final SOBEL mask
    sccd = astropy.nddata.CCDData(sobel_mask, unit=u.adu)
    sccd.write("/Users/tbowers/sandbox/sobel_sum.fits", overwrite=True)

    _, axis = plt.subplots()

    # Compute the iterval
    pmin, pmax = 0, 100
    interval = astropy.visualization.ZScaleInterval(nsamples=10000)
    vmin, vmax = interval.get_limits(sobel_mask)
    # Show the data on the plot, using the limits computed above
    axis.imshow(sobel_mask, vmin=vmin, vmax=vmax, origin="lower")
    axis.axis("off")
    # Finish up
    plt.tight_layout()
    plt.show()
    plt.close()


def make_hpm_fits():
    """Create a Hot Pixel Mask for this data set

    _extended_summary_
    """
    msgs.info("Reading in the ImageFileCollection...")
    icl = ccdproc.ImageFileCollection(
        "/Users/tbowers/sandbox/", glob_include="TARGET*.fit"
    )

    hotpix = generate_hotpixel_mask(icl)

    # Set up the plotting environment for the final SOBEL mask
    sccd = astropy.nddata.CCDData(hotpix, unit=u.adu)
    sccd.write("/Users/tbowers/sandbox/hotpix_sum.fits", overwrite=True)


def find_stars_asc():
    """Find stars in the ALL-SKY IMAGE

    _extended_summary_
    """
    hpm = astropy.nddata.CCDData.read(
        "/Users/tbowers/sandbox/hotpix_sum.fits", unit=u.adu
    )

    ccd = astropy.nddata.CCDData.read(
        "/Users/tbowers/sandbox/TARGET__00323.fit", unit=u.adu
    )
    # LR flip the image and convert to float
    ccd.data = np.fliplr(ccd.data.astype(float))

    ccd.data[hpm.data.astype(bool)] = np.nan
    msgs.bug(f"Number of NaN pixels in masked image: {np.sum(np.isnan(ccd.data))}")

    ccd.data = astropy.convolution.interpolate_replace_nans(
        ccd.data, astropy.convolution.Gaussian2DKernel(x_stddev=1)
    )
    msgs.bug(
        f"Number of NaN pixels in interpolated image: {np.sum(np.isnan(ccd.data))}"
    )
    radius = generate_radius_mask(ccd.data)
    # Mask by radius
    ccd.data[radius.astype(bool)] = np.nan

    _, axis = plt.subplots(figsize=(16, 12))

    interval = astropy.visualization.ZScaleInterval(nsamples=10000)
    vmin, vmax = interval.get_limits(ccd.data)
    # Show the data on the plot, using the limits computed above
    axis.imshow(ccd.data, vmin=vmin, vmax=vmax, origin="lower")
    axis.axis("off")
    # Finish up
    plt.tight_layout()
    plt.savefig("/Users/tbowers/sandbox/finding_stars.png")
    plt.savefig("/Users/tbowers/sandbox/finding_stars.pdf")
    plt.close()


# Testing CLI
if __name__ == "__main__":

    # test_animations()
    # run_test_hotpix()
    # test_masking()
    # make_clean_sobel_map()
    find_stars_asc()
    # make_hpm_fits()
