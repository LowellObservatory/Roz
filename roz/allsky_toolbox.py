# -*- coding: utf-8 -*-
#
#  This Source Code Form is subject to the terms of the Mozilla Public
#  License, v. 2.0. If a copy of the MPL was not distributed with this
#  file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
#  Created on 05-Oct-2022
#
#  @author: tbowers

"""Module containing toolbox utilities for processing All-Sky Images

This module is part of the Roz package, written at Lowell Observatory.

Images from the All-Sky Cameras require aditional specialized processing in
order to make use of the data for sky quality monitoring purposes.  The
routines here are based on algorithms from the `kpno-allsky package
<https://github.com/dylanagreen/kpno-allsky>`_.

This module primarily trades in, um, stuff?

.. include common links, assuming primary doc root is up one directory
.. include:: ../include/links.rst
"""

# Built-In Libraries
import bz2
import gzip
import os
import pathlib
import re
import shutil
import tarfile
import warnings

# 3rd Party Libraries
import astropy.io.fits
import astropy.nddata
from astropy.utils.exceptions import AstropyUserWarning
import ccdproc
import matplotlib.pyplot as plt
import numpy as np
import PIL.Image
from tqdm import tqdm

# Internal Imports
from roz import alerting
from roz import msgs
from roz import utils

# Set API Components
__all__ = []

LDT_ASC = {'xcen': 711, 'ycen':488, 'mrad':520}


def generate_mask(forcenew=False):
    """Generate a complete mask for Lowell All-Sky Images

    The mask generated by this function is a BAD PIXEL MASK, in that a value
    of 0 indicates the pixel should remain visible, and masked pixels are
    marked by bitwise value:

    1. Hot pixels
    2. Horizon objects
    4. Pixels outside the circular All-Sky Image.

    Parameters
    ----------
    forcenew : bool, optional
        Force the generation of a mask completely from scratch rather than use
        a saved mask?  (Default: False)

    Returns
    -------
    `numpy.ndarray`_
        The mask array where 0 represents pixels that are to be masked and 1
        represents pixels that should remain visible.

    See Also
    --------
    generate_object_mask : Used by generate_mask to generate the hot pixel
                    and horizon masks.

    Notes
    -----
    generate_mask calls generate_object_mask, which requires there to be
    median images in Images/mask/ but also additionally requires an image
    named Ignore.png in Images/ that deliniates the horizon objects to be
    ignored. These images can be downloaded from the kpno-allsky github.
    """

    # The other two masks
    mask1 = generate_hotpixel_mask()
    mask2 = generate_object_mask(forcenew)
    mask4 = generate_radius_mask(mask1, forcenew)


def generate_radius_mask(mask1: np.ndarray, forcenew=False):
    """generate_radius_mask _summary_

    _extended_summary_

    Parameters
    ----------
    mask1 : `numpy.ndarray`_
        _description_
    forcenew : bool, optional
        _description_, by default False

    Returns
    -------
    _type_
        _description_
    """
    # The radius Mask
    mask = np.zeros_like(mask1)

    # Construct the arrays for doing the matrix magic -- origin in center
    n_y, n_x = mask1.shape
    x_arr = np.tile(np.arange(n_x), (n_y, 1)) - LDT_ASC['xcen']
    y_arr = np.transpose(np.tile(np.arange(n_y), (n_x, 1))) - LDT_ASC['ycen']
    mask = float(np.hypot(x_arr, y_arr) > LDT_ASC['mrad']) * 4.0

    return mask


def generate_object_mask(forcenew=False):
    """Generate a mask for KPNO images.

    Generates a masking array for KPNO images that masks out not only hot
    pixels, but also the horizon objects.

    Parameters
    ----------
    forcenew : bool, optional
        Whether or not this method should load a previously saved mask or if it
        should generate it completely from scratch.

    Returns
    -------
    numpy.ndarray
        The mask array where 1 represents pixels that are to be masked and 0
        represents pixels that should remain visible.

    See Also
    --------
    generate_clean_mask : Used by generate_mask to generate the hot pixel
                          mask.

    Notes
    -----
    generate_mask requires there to be median images in Images/mask/ but also
    additionally requires an image named Ignore.png in Images/ that
    deliniates the horizon objects to be ignored.
    These images can be downloaded from the kpno-allsky github or may be
    generated by median.median_all_date and moved.

    """
    center = (256, 252)

    # Read in the ignore image.
    # I read this in first to make sure the Mask.png is the correct dimensions.
    ignore_loc = os.path.join(os.path.dirname(__file__), *["Images", "Ignore.png"])
    ignore = np.asarray(PIL.Image.open(ignore_loc).convert("RGB"))

    # If we"ve already generated and saved a mask, load that one.
    # This speeds up code execution by a lot, otherwise we loop through 512x512
    # pixels 6 times! With this we don"t have to even do it once, we just load
    # and go.
    maskloc = os.path.join(os.path.dirname(__file__), *["Images", "Mask.png"])
    if os.path.isfile(maskloc) and not forcenew:
        mask = np.asarray(PIL.Image.open(maskloc).convert("L"))
        # Converts the 255 bit loaded image to binary 1-0 image.
        mask = np.where(mask == 255, 1, 0)

        # Have to compare these two separately, since ignore has a third color
        # dimensions and mask.shape == ignore.shape would therefore always be
        # False.
        if mask.shape[0] == ignore.shape[0] and mask.shape[1] == ignore.shape[1]:
            return mask

    # Get the "clean" mask, i.e. the pixels only ignore mask.
    mask = generate_hotpixel_mask()

    hyp = np.hypot
    for y in range(0, ignore.shape[1]):
        for x in range(0, ignore.shape[0]):
            x1 = x - center[0]
            y1 = center[1] - y
            r = hyp(x1, y1)

            # Ignore horizon objects (which have been painted pink)
            # Only want the horizon objects actually in the circle.
            # Avoids unnecessary pixels.
            if r < 242 and np.array_equal(ignore[y, x], [244, 66, 235]):
                mask[y, x] = 1

    # If we've made a new mask, save it so we can skip the above steps later.
    save_mask(mask)

    return mask


def generate_hotpixel_mask():
    """Generate a clean mask for KPNO images.

    Generates a masking array for KPNO images that only masks out hot pixels.

    Returns
    -------
    numpy.ndarray
        The mask array where 1 represents pixels that are to be masked and 0
        represents pixels that should remain visible.

    Notes
    -----
    generate_clean_mask requires there to be median images in Images/mask/.
    These images can be downloaded from the kpno-allsky github or may be
    generated by median.median_all_date and moved.

    """
    fileloc = os.path.join(os.path.dirname(__file__), *["Images", "Mask"])
    files = os.listdir(fileloc)

    tolerance = 160

    # Sets up the mask to be the right size
    file1 = os.path.join(fileloc, files[0])
    img = np.asarray(PIL.Image.open(file1).convert("L"))
    mask = np.zeros((img.shape[0], img.shape[1]))

    for f in files:
        f = os.path.join(fileloc, f)
        img = np.asarray(PIL.Image.open(f).convert("L"))

        for y in range(0, img.shape[1]):
            for x in range(0, img.shape[0]):
                # 255 is pure white so accept pixels between
                # white-tolerance and white
                # Y is first value as it"s the row value
                if img[y, x] >= (255 - tolerance):
                    mask[y, x] += 1

    # Get only the pixels that appear as "hot" in ALL of the images.
    # Set those to 0 to mask them.
    final = np.where(mask >= np.amax(mask), 1, 0)

    return final


def save_mask(mask):
    """Save a masking image.

    Parameters
    ----------
    mask : numpy.ndarray
        The mask to save.

    See Also
    --------
    image.save_image : Save an image.

    """



# Testing CLI
if __name__ == '__main__':
    ccd = astropy.nddata.CCDData.read('/Users/tbowers/sandbox/TARGET__00571.fit')

    mask = generate_radius_mask(ccd.data)

    _, axis = plt.subplots()

    axis.imshow(ccd.data)

    plt.tight_layout()
    plt.show()
    plt.close()